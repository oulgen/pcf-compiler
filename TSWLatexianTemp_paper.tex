\documentclass{acm_proc_article-sp}

\usepackage{fancyvrb}
\usepackage{mathpartir}
\usepackage{code,proof,amsthm,amssymb,amsmath,stmaryrd}

\input{commands.tex}

\newcommand{\ccb}{\texttt{C0} bytecode }
\newcommand{\ccbi}{\texttt{C0} bytecode}
\newcommand{\clac}{{\em CLAC} language }
\newcommand{\claci}{{\em CLAC} language}

\begin{document}

\title{Compiling Functional Programs to C0 Bytecode}

\numberofauthors{1}
\author{
\alignauthor
Oguz Ulgen\\
       \affaddr{Carnegie Mellon University}\\
       \email{oulgen@andrew.cmu.edu}
}

\date{\today}

\maketitle
\begin{abstract}
Hi, this is my abstract.
\end{abstract}

\terms{Theory, Languages, Compilers}

\keywords{Language definitions, functional programming, C0, bytecode}

\section{Introduction}
Compilers are written to convert a source language to a target language. For practical purposes, the target language is always either a binary form that is referred as object code or an intermediary language that can than recompiled into a binary form. The first case is straight forward since the conversion is done from the source into machine readable format. However, the latter case is not as simple. In most applications, compiler designers chose to compile down to an intermediate language in order to use a highly optimized compiler to generate the machine readable binary form. This intermediate language is generally \texttt{LLVM} language or assembly language.

In this paper, we chose to use \ccb as our intermediate language. It is possible to read about this language on \texttt{http://c0.typesafety.net/}.

Another choice we have made is to compile a functional language, specifically a PCF (Programming Computable Functions) language.

\section{Stack Based Implementation of an interpreter for the {\secit CLAC} Language}
Before moving on to implementing a compiler for the PCF language, we chose to write an interpreter for the \claci. The reason for making this decision stems from the fact that both \clac and \ccb have a stack based procedure for evaluation.

\begin{figure}
\centering
\begin{BVerbatim}
Clac ::= Num Int
          | Op Op
          | Pair
          | Prj1
          | Prj2
          | If
          | Skip

Op ::= Add | Sub | Mult | Div
\end{BVerbatim}
\caption{The \clac definition}
\end{figure}

\begin{figure}
{\small
\[
\begin{array}{rclcrcll}
\multicolumn{3}{c}{\bf Before ~~}  & & \multicolumn{3}{c}{\bf \qquad\quad~~ After} \\ 
\mbox{\bf Stack} & & \mbox{\bf Queue} & & \mbox{\bf Stack} & & {\bf Queue} \\ \hline
%%%%
%%%% Already implemented
%%%% 
S            & \mid\mid & n, Q & \longrightarrow &
S, n         & \mid\mid & Q
\\ \hline
%%%%
%%%% Arith operations
%%%% 
S, x, y      & \mid\mid & \mbox{\texttt{+}}, Q & \longrightarrow & 
S, x\,{+}\,y & \mid\mid & Q
\\
S, x, y      & \mid\mid & \mbox{\texttt{-}}, Q & \longrightarrow & 
S, x\,{-}\,y & \mid\mid & Q
\\
S, x, y      & \mid\mid & \mbox{\texttt{*}}, Q & \longrightarrow & 
S, x\,{*}\,y & \mid\mid & Q
\\
S, x, y      & \mid\mid & \mbox{\texttt{/}}, Q & \longrightarrow & 
S, x\,{/}\,y & \mid\mid & Q
\\ \hline
S, x, y         & \mid\mid & \texttt{Pair}, Q & \longrightarrow & S, \langle x, y\rangle & \mid\mid & Q
\\
S, \langle x, y\rangle         & \mid\mid & \texttt{Prj1}, Q & \longrightarrow & S, x & \mid\mid & Q
\\
S, \langle x, y\rangle         & \mid\mid & \texttt{Prj2}, Q & \longrightarrow & S, y & \mid\mid & Q
\\
S, 0 & \mid\mid & \texttt{If}, \textit{tok}_1, \textit{tok}_2, Q & \longrightarrow & S, \textit{tok}_1 & \mid\mid & Q
\\
S, 1 & \mid\mid & \texttt{If}, \textit{tok}_1, \textit{tok}_2, Q & \longrightarrow & S, \textit{tok}_2 & \mid\mid & Q
\\
S, n         & \mid\mid & \texttt{Skip}, Q & \longrightarrow & S & \mid\mid & Q[n:end]
\end{array}
\]}
\caption{Stack/queue based Clac reference}
\end{figure}

The resemblance between \clac and \ccb enables us to consider \ccb at a more abstract way by just looking at a significantly smaller language that is \claci.

\section{Compilation to {\secit C0} bytecode}

\subsection{Language Constructors}
\begin{figure}
\[
\begin{array}{r c c l l}
\ms{Exp} & e     & ::= &\zero                     & \zero\\
        &        &    & \suc(e)                   & \suc(e)\\
        &        &    & \ifz(e;e_0;x.e_1)         & \ifz ~e~ \{z \goesto e_0 \mid \suc(x) \goesto e_1\}\\
        &        &    & \lam[\tau](x.e)           & \irl{fn}\,(x : \tau)\,e\\
        &        &    & \letexp{x}{e_1}{e_2}      & \letbind{x}{e_1}{e_2} \\
        &        &    & \irl{pair}(e_1;e_2) & \pair{e_1}{e_2}\\
        &        &    & \irl{pr[l]}(e)        & e \cdot \irl{l}\\
        &        &    & \irl{pr[r]}(e)        & e \cdot \irl{r}\\
        &        &    & \inlt(e)        & \irl{inl}[\tau_1; \tau_2] ~e\\
        &        &    & \inrt(e)        & \irl{inr}[\tau_1; \tau_2] ~e\\
        &        &    & \ecase(e; x_1.e_1; x_2.e_2)  & \ecase~e~\{\irl{inl}~x_1 \goesto e_1 \mid \irl{inr}~x_2 \goesto e_2\}
\end{array}
\]
\caption{PCF language reference}
\end{figure}
\subsection{Representations}
\subsection{Translation}

\section{Conclusions}

\section{Acknowledgments}

\input{appendix.tex}

\end{document}
